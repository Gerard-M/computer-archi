import type { Instruction } from "./types"

export const instructionSet: Instruction[] = [
  // Arithmetic Instructions
  {
    id: 1,
    mnemonic: "MOV AX, 42",
    description: "Store the value 42 in register AX",
    type: "arithmetic",
    operands: 2,
    beginner_explanation: "This is like putting the number 42 into a box labeled 'AX'",
  },
  {
    id: 2,
    mnemonic: "ADD AX, BX",
    description: "Add BX to AX and store result in AX",
    type: "arithmetic",
    operands: 2,
    beginner_explanation: "This adds the values in boxes 'AX' and 'BX', then puts the result in 'AX'",
  },
  {
    id: 3,
    mnemonic: "SUB CX, DX",
    description: "Subtract DX from CX and store in CX",
    type: "arithmetic",
    operands: 2,
    beginner_explanation: "This subtracts the value in 'DX' from 'CX', then puts the result in 'CX'",
  },
  {
    id: 4,
    mnemonic: "MUL BX",
    description: "Multiply AX by BX and store in AX",
    type: "arithmetic",
    operands: 1,
    beginner_explanation: "This multiplies the values in 'AX' and 'BX', then puts the result in 'AX'",
  },
  {
    id: 5,
    mnemonic: "DIV CX",
    description: "Divide AX by CX and store in AX",
    type: "arithmetic",
    operands: 1,
    beginner_explanation: "This divides the value in 'AX' by the value in 'CX', then puts the result in 'AX'",
  },
  {
    id: 6,
    mnemonic: "INC CX",
    description: "Increment CX by 1",
    type: "arithmetic",
    operands: 1,
    beginner_explanation: "This adds 1 to the value in 'CX'",
  },
  {
    id: 7,
    mnemonic: "DEC BX",
    description: "Decrement BX by 1",
    type: "arithmetic",
    operands: 1,
    beginner_explanation: "This subtracts 1 from the value in 'BX'",
  },

  // Logical Instructions
  {
    id: 8,
    mnemonic: "AND AX, 0xFF",
    description: "Bitwise AND AX with 0xFF",
    type: "logical",
    operands: 2,
    beginner_explanation: "This keeps only the last 8 bits of the value in 'AX'",
  },
  {
    id: 9,
    mnemonic: "OR BX, CX",
    description: "Bitwise OR BX with CX and store in BX",
    type: "logical",
    operands: 2,
    beginner_explanation: "This combines the bits in 'BX' and 'CX' using OR logic",
  },
  {
    id: 10,
    mnemonic: "XOR DX, DX",
    description: "XOR DX with itself (sets to zero)",
    type: "logical",
    operands: 2,
    beginner_explanation: "This is a clever way to set 'DX' to zero",
  },
  {
    id: 11,
    mnemonic: "NOT AX",
    description: "Bitwise NOT of AX (flip all bits)",
    type: "logical",
    operands: 1,
    beginner_explanation: "This flips all the bits in 'AX' (0s become 1s, and 1s become 0s)",
  },
  {
    id: 12,
    mnemonic: "CMP AX, BX",
    description: "Compare AX with BX and set flags",
    type: "logical",
    operands: 2,
    beginner_explanation: "This checks if 'AX' and 'BX' are equal and remembers the result",
  },

  // Data Movement Instructions
  {
    id: 13,
    mnemonic: "MOV BX, AX",
    description: "Copy value from AX to BX",
    type: "data",
    operands: 2,
    beginner_explanation: "This copies the value from box 'AX' to box 'BX'",
  },
  {
    id: 14,
    mnemonic: "PUSH AX",
    description: "Push value of AX onto the stack",
    type: "data",
    operands: 1,
    beginner_explanation: "This puts the value in 'AX' on top of a stack of values",
  },
  {
    id: 15,
    mnemonic: "POP BX",
    description: "Pop value from stack into BX",
    type: "data",
    operands: 1,
    beginner_explanation: "This takes the top value from the stack and puts it in 'BX'",
  },
  {
    id: 16,
    mnemonic: "XCHG AX, BX",
    description: "Exchange values in AX and BX",
    type: "data",
    operands: 2,
    beginner_explanation: "This swaps the values in 'AX' and 'BX'",
  },
  {
    id: 17,
    mnemonic: "MOV AX, [100]",
    description: "Load value from memory address 100 into AX",
    type: "data",
    operands: 2,
    beginner_explanation: "This gets a value from memory location 100 and puts it in 'AX'",
  },
  {
    id: 18,
    mnemonic: "MOV [200], BX",
    description: "Store value of BX into memory address 200",
    type: "data",
    operands: 2,
    beginner_explanation: "This puts the value in 'BX' into memory location 200",
  },

  // Control Flow Instructions
  {
    id: 19,
    mnemonic: "JMP 0x100",
    description: "Jump to memory address 0x100",
    type: "control",
    operands: 1,
    beginner_explanation: "This tells the CPU to continue from memory location 0x100",
  },
  {
    id: 20,
    mnemonic: "JE 0x200",
    description: "Jump to 0x200 if equal flag is set",
    type: "control",
    operands: 1,
    beginner_explanation: "If the last comparison was equal, continue from location 0x200",
  },
  {
    id: 21,
    mnemonic: "JNE 0x300",
    description: "Jump to 0x300 if equal flag is not set",
    type: "control",
    operands: 1,
    beginner_explanation: "If the last comparison was not equal, continue from location 0x300",
  },
  {
    id: 22,
    mnemonic: "CALL 0x400",
    description: "Call subroutine at address 0x400",
    type: "control",
    operands: 1,
    beginner_explanation: "This runs a mini-program at location 0x400 and then comes back",
  },
  {
    id: 23,
    mnemonic: "RET",
    description: "Return from subroutine",
    type: "control",
    operands: 0,
    beginner_explanation: "This returns back to where you were after a CALL instruction",
  },

  // I/O Instructions
  {
    id: 24,
    mnemonic: "IN AX, 60h",
    description: "Input from port 60h to AX",
    type: "io",
    operands: 2,
    beginner_explanation: "This gets input from device 60h (like a keyboard) and puts it in 'AX'",
  },
  {
    id: 25,
    mnemonic: "OUT 61h, AL",
    description: "Output AL to port 61h",
    type: "io",
    operands: 2,
    beginner_explanation: "This sends the value in 'AL' to device 61h (like a speaker)",
  },
]

// Group instructions by type for easier access
export const instructionsByType = {
  arithmetic: instructionSet.filter((inst) => inst.type === "arithmetic"),
  logical: instructionSet.filter((inst) => inst.type === "logical"),
  data: instructionSet.filter((inst) => inst.type === "data"),
  control: instructionSet.filter((inst) => inst.type === "control"),
  io: instructionSet.filter((inst) => inst.type === "io"),
}
